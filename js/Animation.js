/*jslint esversion:6 */
'use strict'

/*
Суть - вся анимация для каждого вида используемых сущностей (игрок/монстры/стрелы) записана в одном большом пнг-файле

на страничке выводится прямоугольный блок, в котором виден только фрагмент этого большого файла
например, "показать фрагмент, который начинается с отступом 100 точек вправо и 200 точек вниз от левого верхнего угла картинки"
чтобы эти отступы узнать, этот класс и сделан

Сам класс - несколько объектов с кучей чисел каждый

эти числа задаются в файле AnimationParameters.js
структура данных объекта и в файле AnimationParameters.js аналогична:

this.url        - строка, задает адрес к общей картинке (картинка одна общая для всех)

this[animMode]  - объект (по объекту на каждый доступный режим анимации)
                {
                    startY      - отступ по оси Y (вертикали), с которого в большом файле начинаются кадры этой анимации
                    totalFrames - количество кадров анимации
                    isCycled    - флаг, циклична ли эта анимация
                                  если да, то после последнего кадра анимации будет показываться её первый кадр, 
                                  если нет, вернется доп флаг "animationEnded"
                    frameW      - ширина одного кадра анимации
                    frameH      - высота одного кадра анимации
                    xDifferenceLeft - ширина "выступающих" частей слева
                                      если например анимация - монстр с дубинкой, то это ширина дубинки
                                      нужно потому, что для отрисовки важен весь рисунок, 
                                      а для игровой логики - где у монстра туловище, а не дубинка
                }
*/

export class Animation {
    constructor( object ){
        Object.assign( this, object );      // копируем объект с сохранением структуры

        this.url = 'url('+ object.url +')'; // подправляем ссылку на изображение
    }

    getNextFrameParams( animMode, modeChanged, lastShownFrameNum ){
        /* возвращает объект
        {
            url
            xOffset
            yOffset
            imageTo
            newFrameNum
            animationEnded
            frameW
            frameH
            xDifferenceLeft
        }
        */

        let frameNum,
            an = this[animMode],    //короткая ссылка для удобства

            result = {
                url : this.url, 
                xOffset :       '', 
                yOffset :       an.startY + 'px',
                newFrameNum :   0,
                animationEnded: false,
                frameW:         an.frameW,
                frameH:         an.frameH,
                xDifferenceLeft: an.xDifferenceLeft
            };

        if (modeChanged === true) {
            // надо показать новую анимацию с начала (нулевого кадра)
            // начинается в большой файле он с x = 0, y = this.animMode.startY
            result.xOffset = '0px';

        } else {
            // анимация проигрывается дальше, надо показать следующий кадр
            //
            // следующий кадр = прошлый+1, но надо обрабатывать случаи, когда это число больше итогового количества кадров 
            // (должно происходить только для циклической анимации, конечная анимация при показе последнего кадра должна переключать режим в idle)
            frameNum = lastShownFrameNum + 1;

            if ( frameNum == (an.totalFrames-1) ) {
                // дошли до последнего кадра (при кол-ве кадров 3, максимальный индекс = 2, т.к. нумерация с нуля)
                if ( !an.isCycled ) {
                    // и при этом анимация не зациклена - поставить флаг "конец анимации"
                    frameNum = an.totalFrames-1;
                    result.animationEnded = true;
                }
                // если анимация зациклена, то последний её кадр ничем особенным не выделяется

            }
            // последний кадр был показан ранее, а теперь должен быть показан кадр после последнего
            // (это возможно только для зацикленных анимаций)
            if ( frameNum > (an.totalFrames-1) ) {

                if (an.isCycled === true ) {
                    // показать снова первый кадр
                    frameNum = 0;
                }
            }

            result.newFrameNum = frameNum;
            result.xOffset = ( this.wTotal - an.frameW*frameNum ) + 'px';
        }
        return result;
    }
}